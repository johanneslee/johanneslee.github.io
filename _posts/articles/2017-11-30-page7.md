---
layout: post
title: 자바 7 와 자바 8 의 차이에 대하여
excerpt: "나는 어떤 자바를 사용했을까"
modified: 2017-11-30T00:00:00-00:00
categories: articles
comments: true
share: true
---

### 나는 자바의 철학에 대해 알고 있는가

정말 부끄러운 일이지만, 나는 내가 어떤 자바를 사용했는지 알지 못 했다. 아니, 버전이라는 것에 대한 개념 자체에 대해 잘 알지 못 했다. 처음 크로스 브라우징을 경험하면서 IE 8 을 지원하는 것에 대한 이슈로 버전에 대해 처음 관심을 가졌다. 그것도 호환이 되느냐, 안 되느냐 정도로 가볍게. 그리고 두 번의 인터뷰를 보았다.

> 음, 사용하고 있는 기술이 어떤 철학을 갖고 있는지 같은 대답 말이에요.

처음 면접을 보면서 최근 내가 사용하는 기술에 대한 설명을 듣고, 담당자가 그 기술이 어떤 철학을 가지고 있는 지 물었다. 나는 그냥 손에 잡히고 눈에 띄는 코드를 사용해 왔는데, 철학이란 말은 정말 난데없이 튀어나온 말이었다. 그 분은 면접을 마무리하면서 내게 최신 자바스크립트의 동향을 공부하면 도움이 될 거라고 했다. 그리고 나는 그 분이 말씀하신 대로 최신 자바스크립트를 찾아보고 ES6 의 문법을 공부하기 시작했다. 그 과정에서 React, Webpack, Babel 등을 접하게 되었고 사용하기 위해 웹사이트를 만들었다.

아직 그 철학이라는 게 뭔지는 잘 모르겠다. 지금은 '아마도 기술의 근간이 되는 핵심 개념을 말하는 게 아닐까' 정도로만 생각하고 있다. 예를 들어, React 가 기존의 DOM 구조가 매번 조작할 때마다 전체 레이아웃을 재구성하는 불필요한 연산 과정에 불합리함을 느꼈고, 모든 변화를 가상의 DOM 에 모아 한 번에 적용시켜 연산을 줄이는 개념의 Virtual DOM 을 채택한 것처럼.

### 그렇다면 자바의 철학은 과연 뭘까

이 주제에 대해 생각나는 건 두 가지가 있다. 플랫폼에 독립적이고, 객체지향 언어라는 것. 플랫폼에 독립적인 것은 JVM 의 덕분인데, 여기에 내가 관여할 부분이 있는지 잘 모르겠다. 그렇다면 남는 것은 객체지향 언어라는 것이다. 이 주제에 대해서는 개발자가 마땅히 관여해야 하는 부분이고, 효과적인 객체지향적 개발을 위해 많은 도구들이 지원되고 있다. 대표적으로 클래스 사이의 독립성과 캡슐화를 돕는 인터페이스가 있다.

{% highlight Java %}
  public interface Predator {
      public String getFood();
  }

  public class Tiger extends Animal implements Predator {
    public String getFood() {
        return "apple";
    }
  }

  public class Lion extends Animal implements Predator {
    public String getFood() {
        return "banana";
    }
  }

  public class ZooKeeper {    
    public void feed(Predator predator) {
        System.out.println("feed " + predator.getFood());
    }
  }
{% endhighlight %}

자바는 여기에 그치지 않고 지속적으로 버전을 높이면서 개발자들의 개발을 돕기 위한 많은 도구들을 만들어 왔다.

### 자바 7 부터 지원되는 것들 - Language enhancements

* Diamond Operator

제네릭스는 자바에 도입된 개념 중에 하나이다. 자바는 자료형 타입 바로 옆에 <String> 과 같은 문구를 추가하여 '이 자료형 타입 안에 담을 수 있는 자료형은 String 타입 뿐이다' 라고 선언할 수 있도록 지원했다. 그럼으로써 제네릭스를 사용하지 않았을 때 발생했던 예상치 못 한 데이터의 자료형 변동이나 형변환 과정의 불편함 등을 해소할 수 있었다.

{% highlight Java %}
  Map<String, List<Trade>> trades = new TreeMap<String, List<Trade>> ();
{% endhighlight %}

그런데, 우리는 이것을 사용하기 위해 자료형을 양쪽에 모두 작성해야 한다는 불편함이 있었다. 자바 7 에서는 왼쪽에 선언한 것을 바탕으로 컴파일러가 타입을 추측할 수 있도록 지원했다. 따라서, 이제는 다음과 같이 코드를 작성할 수 있다.

{% highlight Java %}
  Map<String, List<Trade>> trades = new TreeMap <> ();
{% endhighlight %}

오른쪽에 있는 <> 지시자가 바로 Diamond Operator 이다.

* Using strings in switch statements

Switch 문은 Primitive 자료형이나 Enumerated 자료형을 사용할 수 있었다. 자바 7 부터는 Switch 문에 String 자료형을 사용할 수 있게 된다.

{% highlight Java %}
  private void processTrade(Trade t) {
    String status = t.getStatus();
    if (status.equalsIgnoreCase(NEW)) {
      newTrade(t);
    } else if (status.equalsIgnoreCase(EXECUTE)) {
      executeTrade(t);
    } else if (status.equalsIgnoreCase(PENDING)) {
      pendingTrade(t);
    }
  }
{% endhighlight %}

자바 7 에서는 이 코드를 String 자료형을 변수로 받는 향상된 Switch 문으로 아래와 같이 작성할 수 있다.

{% highlight Java %}
  public void processTrade(Trade t) {
    String status = t.getStatus();
    switch (status) {
      case NEW:
    newTrade(t);
    break;
      case EXECUTE:
    executeTrade(t);
    break;
      case PENDING:
    pendingTrade(t);
    break;
      default:
    break;
    }
  }
{% endhighlight %}

* Automatic resource management

Connection, Files, Input/OutStream 등과 같은 리소스는 개발자가 수동으로 회수해야 했다. 우리는 종종 각각의 자원을 회수하기 위해 아래와 같이 Try-Finally 블록을 사용한다.

{% highlight Java %}
  public void oldTry() {
    try {
      fos = new FileOutputStream("movies.txt");
      dos = new DataOutputStream(fos);
      dos.writeUTF("Java 7 Block Buster");
    } catch (IOException e) {
      e.printStackTrace();
    } finally {
      try {
    fos.close();
    dos.close();
      } catch (IOException e) {
    // log the exception
      }
    }
  }
{% endhighlight %}

하지만, 자바 7 에서는 리소스를 자동으로 관리하는 기능을 지원한다. 다음과 같이 Try 문 안에 리소스를 선언하면 된다.

{% highlight Java %}
  public void newTry() {
    try (FileOutputStream fos = new FileOutputStream("movies.txt");
    DataOutputStream dos = new DataOutputStream(fos)) {
      dos.writeUTF("Java 7 Block Buster");
    } catch (IOException e) {
      // log the exception
    }
  }
{% endhighlight %}

위의 코드를 보면, 여러 리소스들에도 동작한다. FileOutputStream 과 DataOutputStream 은 각각 세미콜론(;)으로 나뉘어진 채로 Try 문 안에 들어있다. Try 문에서 자동으로 회수하므로, 직접 스트림을 Null 처리하거나 회수할 필요가 없다. 다만, 리소스들은 내부적으로 java.lang.AutoCloseable 인터페이스가 구현되어 있어야 한다.

AutoCloseble 인터페이스가 구현한 리소스들은 Automatic resource management 의 후보가 될 수 있다. AutoCloseable 은 java.io.Closeable 인터페이스의 부모 클래스이고 오직 close() 메서드 하나만을 가지고 있다. 이 close() 메서드는 Try 블록이 나왔을 때에 JVM 에 의해서 호출된다.

* Numeric literals with underscores

확실히, 숫자는 눈에 피로를 준다. 만약 0이 10개쯤 있는 숫자를 받으면 당신은 0 을 세어보기 시작할 것이다. 만약 100만, 또는 10억의 숫자가 있는데 당신이 오른쪽에서부터 차근차근 자릿수를 세지 않는다면 분명 쉽게 실수할 것이다. 자바 7 에서는 자릿수를 표시하기 위한 Underscores 를 지원한다. 당신은 1000을 다음과 같이 선언할 수 있다.

{% highlight Java %}
  int thousand =  1_000;
{% endhighlight %}

그리고, 1000000을 다음과 같이 선언할 수 있다.
{% highlight Java %}
  int million  =  1_000_000
{% endhighlight %}

그리고, 자바 7 에서는 2진수에 대해서도 "0b1" 과 같이 표현할 수 있도록 지원하기 때문에 개발자들이 더 이상 이것을 16진수로 변환하지 않아도 된다.

* Improved exception handling

자바 7 에서는 예외처리에 대해 향상된 점이 2가지가 있다. 첫 번째로, 하나의 Catch 문에서 여러 개의 예외처리를 할 수 있는 Multi-catch 기능이다. 이전 버전에서 3개의 예외처리 메서드가 있다면 다음과 같이 표현할 수 있을 것이다.

{% highlight Java %}
  public void oldMultiCatch() {
    try {
      methodThatThrowsThreeExceptions();
    } catch (ExceptionOne e) {
      // log and deal with ExceptionOne
    } catch (ExceptionTwo e) {
      // log and deal with ExceptionTwo
    } catch (ExceptionThree e) {
      // log and deal with ExceptionThree
    }
  }
{% endhighlight %}

Catch 블록 안에 셀 수 없이 많은 예외를 하나씩 처리하는 모습은 어수선해 보이고, 비효율적이며, 오류를 범하기 쉽다. Java 7 에서는 이 코드를 향상된 Catch 문으로 아래와 같이 작성할 수 있다.

{% highlight Java %}
  public void newMultiCatch() {
    try {
      methodThatThrowsThreeExceptions();
    } catch (ExceptionOne | ExceptionTwo | ExceptionThree e) {
      // log and deal with all Exceptions
    }
  }
{% endhighlight %}

여러 개의 예외들은 "|" 연산자를 사용해 하나의 Catch 문 안에서 처리할 수 있다. 그러나 다른 타입에 속하는 여러 개의 예외가 있다면 "Multi Multi-catch" 블록을 이용하면 된다.

{% highlight Java %}
  public void newMultiMultiCatch() {
    try {
      methodThatThrowsThreeExceptions();
    } catch (ExceptionOne e) {
      // log and deal with ExceptionOn
    } catch (ExceptionTwo | ExceptionThree e) {
      // log and deal with ExceptionTwo and ExceptionThree
    }
  }
{% endhighlight %}

다른 카테고리에 속하는 ExceptionTwo 와 ExceptionThree 는 분리되어, 또 하나의 Catch 블록에서 처리되었다.

### 자바 7 부터 지원되는 것들 - New file system API (NIO 2.0)

* Working with Path

java.nio.file 는 새롭게 추가된 패키지로 Path, Paths, FileSystem, FileSystems 와 같은 클래스와 인터페이스로 구성되어 있다.

Path 는 File 경로의 Reference 이다. java.io.File 과 비슷하나, 더 많은 특징을 가지고 있다. Temp 폴더의 Path Reference 는 다음과 같이 얻을 수 있다.

{% highlight Java %}
  public voidpathInfo() {
    Path path= Paths.get("c:\Temp\temp");
    System.out.println("Number of Nodes:"+ path.getNameCount());
    // Number of Nodes:2
    System.out.println("File Name:"+ path.getFileName());
    // File Name:temp.txt
    System.out.println("File Root:"+ path.getRoot());
    // File Root:c:
    System.out.println("File Parent:"+ path.getParent());
    // File Parent:c:Temp
  }
{% endhighlight %}

Files 클래스에 있는 delete 메서드를 호출하면 간단하게 파일이나 디렉토리를 삭제할 수 있다. Files 클래스는 NoSuchFileException 을 처리하는 것과 처리하지 않는 2개의 delete 메서드를 가지고 있다.

아래에 delete 메서드 호출은 NoSuchFileException 를 Throw 하기 때문에 이를 처리해야 한다.

{% highlight Java %}
Files.delete(path);
{% endhighlight %}

만약 file 또는 디렉토리가 존재하지 않으면 Files.deleteIfExists(path) 는 예외를 던지지 않는다.

Files.copy(..) 나 Files.move(..) 처럼 File System 에 효율적인 메서드 또한 이용할수 있다. 링크를 만들고 싶으면 간단하게 createSymbolicLink(..) 메서드를 사용하면 된다.

* File change notifications

File Change Notifications 이 추가된 것은 이번 JDK7 릴리즈에서 가장 마음에 드는 점 중 하나이다. 이 기능을 오랫동안 기다려왔고 마침내 NIO 2.0에 추가되었다. WatchService API 는 변화에 따라 Notification 이벤트를 받게 해준다.

API 는 아래와 같은 단계로 구현한다:

1. WatchService 를 생성한다. 이 서비스는 WatchKeys 를 가진 Queue 로 이루어져 있다.
2. 이 WatchService 로 모니터링하고 싶은 디렉토리/파일을 등록한다.
3. 등록하면서, 받고 싶은 이벤트의 타입(추가/수정/삭제)을 정의한다.
4. 이벤트를 Listen 하는 무한루프를 실행한다.
5. 이벤트가 발생하면 WatchKey 가 Queue 에 쌓인다.
6. WatchKey 를 소모하고 쿼리를 호출한다.

특정 디렉토리를 감시하는 DirPolice 프로그램을 만들어 보자. 아래와 같은 단계로 이루어진다:

{% highlight Java %}
  // 1. WatchService 객체를 생성한다.
  WatchService  watchService = FileSystems.getDefault().newWatchService();

  // 2. 감시할 디렉토리의 Path Reference 를 불러온다.
  // 파일명을 하드코딩 대신 파라미터로 전달하는 것을 권장한다.
  path = Paths.get("C:\Temp\temp\");

  // 3. WatchService 가 모든 타입의 이벤트를 감시하도록 디렉토리를 등록한다.
  // 이벤트 타입들은 java.nio.file.StandardWatchEventKinds 에 정의되어 있다.
  dirToWatch.register(watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);

  // 4. 이벤트를 Listen 하기 위해 무한루프를 초기화한 후, 시작한다.
  while(true) {
    // 여기에서 Key 가 발생한다.
    WatchKey key = watchService.take();
  }

  // 5. 키가 발생하면 이벤트가 실행된다.
  for (WatchEvent event : key.pollEvents()) {
    Kind kind = event.kind();
    System.out.println("Event on " + event.context().toString() + " is " + kind);
  }
  // Temp 디렉토리를 수정/삭제하면 아래와 같이 출력된다.
  // Event on temp is ENTRY_MODIFY
  // Event on temp is ENTRY_DELETE
{% endhighlight %}

DirPolice 전체 소스는 다음과 같다:
([전체 소스코드 다운로드](http://cdn.oreilly.com/radar/2011/08/0811-java7.zip))
{% highlight Java %}
  // This initiates the police
  private void init() {
    path = Paths.get("C:\Temp\temp\");
    try {
      watchService = FileSystems.getDefault().newWatchService();
      path.register(watchService, ENTRY_CREATE, ENTRY_DELETE,
          ENTRY_MODIFY);
    } catch (IOException e) {
      System.out.println("IOException"+ e.getMessage());
    }
  }

  // The police will start making rounds
  private void doRounds() {
    WatchKey key = null;
    while(true) {
      try {
        key = watchService.take();
        for (WatchEvent event : key.pollEvents()) {
          Kind kind = event.kind();
          System.out.println("Event on " + event.context().toString() +
              " is " + kind);
        }
      } catch (InterruptedException e) {
        System.out.println("InterruptedException: "+e.getMessage());
      }
      boolean reset = key.reset();
      if(!reset)
        break;
    }
  }
{% endhighlight %}

* Fork and Join

Java 에서 Parallel Core 들을 효과적으로 사용하는 것은 언제나 어려웠다. 작업을 여러 개의 Core 에 분산시키고 Result Set 을 리턴하기 위해 그것들을 Join 하는 Framework 는 이제껏 거의 없었다. Java 7 은 이 기능을 Fork and Join Framework 로써 포함시켰다.

기본적으로 Fork and Join 은 Task 를 더이상 나누지 않아도 해결할 수 있을 때까지 나눈다. Divide-and-Conquer 알고리즘과 비슷하다. 이 Framework 의 핵심 개념 한 가지는 이상적인 상태에서 Worker Thread 들은 더이상 유휴상태가 되지 않는다는 것이다. 일감이 떨어진 Worker 가 바쁜 Worker 로부터 작업을 "훔치는" Work-Stealing Algorithm 이 구현되어 있다.

ForkJoinPool 과 ForkJoinTask 는 Fork-Join 메카니즘을 지원하는 Core Class 이다. ForkJoinPool 은 Work-Stealing Algorithm 을 구현한 ExecutorService 를 특화시켜서 구현한 것이다.

프로세서들을 인자로 ForkJoinPool 객체를 생성할 수 있다.

{% highlight Java %}
  ForkJoinPool pool = new ForkJoinPool(numberOfProcessors)
{% endhighlight %}

여기서 numberOfProcessors = Runtime.getRunTime().availableProcessors();

그러나 ForkJoinPool의 기본 인스턴스는 위에서 얻은 동일한 개수로 동일한 단계로 설정 해야 한다.

해결해야 할 문제는 ForkJoinTask 안에 만들어져 있다. 그러나 RecursiveAction 과 RecursiveTask 클래스는 특별하게 구현되어 있다. 이 2개 클래스의 차이점은 앞에것은 리턴값이 없는 반면에 뒤에것은 특정 타입의 오브젝트를 리턴한다는 것이다.

여기 당신의 요구사항을 나타낸 RecursiveAction 와 RecursiveTask 클래스를 어떻게 생성하는지 보여주고 있다.(나는 RecursiveAction 클래스를 사용했다.)

{% highlight Java %}
  public class MyBigProblemTask extends RecursiveAction {
    @Override
    protected void compute() {
      . . . // your problem invocation goes here
    }
  }
{% endhighlight %}

당신은 computing 기능을 필요하는 곳에 compute 메서드를 Override 해야한다. 그리고 ForkJoinPool 안에 있는 호출 메서드 부름으로써 ForkJoinTask를 Executor에 전달한다.

{% highlight Java %}
  pool.invoke(task);
{% endhighlight %}

* Supporting dynamism

Java는 변수, 메서드와 리턴값의 타입이 Compile 단계에서 결정되는 정적 언어이다. JVM 은 Runtime 단계에서 타입 정보를 찾을 필요없이 철저하게 정의된 바이트코드를 실행한다.

타입이 동적으로 정해지는 언어들도 있다. Ruby, Python, Clojure 가 그렇다. 이 언어들은 타입이 Runtime 단계에서 결정된다.

자바 진영에서 동적 언어를 효율적으로 임시 처리하는 것에 대한 수요가 커졌다. 그동안 JVM 에서 동적 언어를 실행할 수는 있었지만, 상당한 제약과 제한이 있었다.

Java 7 에서 동적 호출이라는 새로운 기능이 추가되었다. 이것은 자바 이외의 언어의 요구사항을 처리할 수 있도록 VM 을 변화시킨다. java.lang.invoke 라는 새로운 패키지는 MethodHandle, CallSite 등과 같은 클래스로 구성되어 있고, 동적 언어에 대한 지원을 확장하기 위해 만들어졌다.

### 자바 8 의 특징

작성 중입니다.

출처 : [A look at Java 7's new features By Madhusudhan Konda](https://www.oreilly.com/learning/java7-features)  
출처 : [한빛출판네트워크](http://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS9451408435)
